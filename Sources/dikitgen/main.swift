import Foundation
import DIKit
import SourceKittenFramework
import Stencil

func files(atPath path: String) -> [File] {
    let url = URL(fileURLWithPath: path)
    let fileManager = FileManager.default
    let enumerator = fileManager.enumerator(atPath: path)

    var files = [] as [File]
    while let subpath = enumerator?.nextObject() as? String {
        let url = url.appendingPathComponent(subpath)
        guard url.lastPathComponent != ".DS_Store" else {
            continue
        }

        var isDirectory = false as ObjCBool
        if fileManager.fileExists(atPath: url.path, isDirectory: &isDirectory) {
            if isDirectory.boolValue {
                files.append(contentsOf: dikitgen.files(atPath: url.path))
            } else if let file = File(path: url.path) {
                files.append(file)
            }
        }
    }

    return files
}

struct A: Injectable {
    struct Dependency {}
    init(dependency: Dependency) {}
}

struct B: Injectable {
    struct Dependency {
        let ba: A
    }
    
    init(dependency: Dependency) {}
}

struct C: Injectable {
    struct Dependency {
        let ca: A
        let cd: D
    }
    
    init(dependency: Dependency) {}
}

struct D {}

protocol DemoResolver: DIKit.Resolver {
    func provideD() -> D
}

guard CommandLine.arguments.count == 2 else {
    print("error: invalid arguments")
    print("usage: dikitgen <path to source code directory>")
    exit(1)
}

let path = CommandLine.arguments[1]
let types = Array(files(atPath: path)
    .map { file in
        return Structure(file: file)
            .substructures
            .flatMap { Type(structure: $0, file: file) }
    }
    .joined())

let injectableTypeNodes = types.flatMap(Node.init(injectableType:))
let resolvers = types.flatMap { Resolver(type: $0, injectableTypeNodes: injectableTypeNodes ) }

let context = [
    "resolvers": resolvers,
]

let template = Template(templateString: """
//
//  Resolver.swift
//  Generated by dikitgen.
//
{% for resolver in resolvers %}
extension {{ resolver.name }} { {% for factoryMethod in resolver.factoryMethods %}
    func {{ factoryMethod.name }}() -> {{ factoryMethod.returnTypeName }} {
        {% for line in factoryMethod.bodyLines %}{{ line }}{% if not forloop.last %}
        {% endif %}{% endfor %}
    }{% if not forloop.last %}
    {% endif %}{% endfor %}
}
{% endfor %}
""")

let rendered = try template.render(context)
print(rendered)
